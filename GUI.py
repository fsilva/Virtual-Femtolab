#!/usr/bin/env python
# -*- coding: us-ascii -*-
# generated by wxGlade 0.6.3 on Mon Jul 27 14:34:59 2009

import wxversion
wxversion.ensureMinimal('2.8')

import wx
import wx.grid
import wx.lib.scrolledpanel
import sys
import pickle
from numpy import array,vstack,hstack,transpose

import propagator
import draw_schematic
import csv_utils
import plots
import config


# begin wxGlade: extracode
# end wxGlade



class VFFrame(wx.Frame):
    
    
    
################################ initialization functions ################################
    
    def __init__(self, *args, **kwds):
        # begin wxGlade: VFFrame.__init__
        kwds["style"] = wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)
        
        # Menu Bar
        self.MainFrame_menubar = wx.MenuBar()
        
        wxglade_tmp_menu = wx.Menu()
        self.menu_load_id = wx.NewId()
        wxglade_tmp_menu.Append(self.menu_load_id, "Open", "", wx.ITEM_NORMAL)
        self.menu_save_id = wx.NewId()
        wxglade_tmp_menu.Append(self.menu_save_id, "Save", "", wx.ITEM_NORMAL)
        wxglade_tmp_menu.AppendSeparator()
        self.menu_exit = wx.NewId()
        wxglade_tmp_menu.Append(self.menu_exit, "Exit", "", wx.ITEM_NORMAL)
        self.MainFrame_menubar.Append(wxglade_tmp_menu, "File")
        
        wxglade_tmp_menu = wx.Menu()
        self.menu_compwindow_id = wx.NewId()
        wxglade_tmp_menu.Append(self.menu_compwindow_id, "Computational Window", "", wx.ITEM_NORMAL)
        self.menu_centralwavelength_id = wx.NewId()
        wxglade_tmp_menu.Append(self.menu_centralwavelength_id, "Central Wavelength", "", wx.ITEM_NORMAL)

        self.MainFrame_menubar.Append(wxglade_tmp_menu, "Options")
        wxglade_tmp_menu = wx.Menu()
        self.menu_exportplots_id = wx.NewId()
        wxglade_tmp_menu.Append(self.menu_exportplots_id, "Export Plots/Animations", "", wx.ITEM_NORMAL)
        self.menu_exportdata_id = wx.NewId()
        wxglade_tmp_menu.Append(self.menu_exportdata_id, "Export Data", "", wx.ITEM_NORMAL)
        self.MainFrame_menubar.Append(wxglade_tmp_menu, "Export")
        
        wxglade_tmp_menu = wx.Menu()
        self.MainFrame_menubar.Append(wxglade_tmp_menu, "About")
        self.SetMenuBar(self.MainFrame_menubar)
        # Menu Bar end

        self.AddButton = wx.Button(self, wx.ID_ADD, "")
        self.EditButton = wx.Button(self, wx.ID_PROPERTIES, "")
        self.RemoveButton = wx.Button(self, wx.ID_REMOVE, "")
        self.findwaist_id = wx.NewId()
        self.FindWaistButton = wx.Button(self, self.findwaist_id, "Find Next Waist")
        self.VFData = wx.grid.Grid(self)#, -1,  size=(255,400))
        self.SchematicPanel = wx.Panel(self, -1)
        self.DistanceSlider = wx.Slider(self, -1, 0, 0, 1000)
        self.DistanceText = wx.TextCtrl(self, -1, "0", style=wx.TE_RIGHT|wx.TE_PROCESS_ENTER)
        self.DistanceLabel = wx.StaticText(self, -1, 'm')
        
        # Add Matplotlib widgets to window
        self.plot = plots.FourPlots(self)

        self.__set_properties()

        #Set Parameter Values in Grid
        self.init_grid_information()

        self.__do_layout()
        
        self.Bind(wx.EVT_MENU, self.menu_computational_window_click, id=self.menu_compwindow_id)
        self.Bind(wx.EVT_MENU, self.menu_central_wavelength_click, id=self.menu_centralwavelength_id)
        self.Bind(wx.EVT_MENU, self.menu_open_click, id=self.menu_load_id)
        self.Bind(wx.EVT_MENU, self.menu_save_click, id=self.menu_save_id)
        self.Bind(wx.EVT_MENU, self.menu_exit_click, id=self.menu_exit)
        self.Bind(wx.EVT_MENU, self.menu_exportplots_click, id=self.menu_exportplots_id)
        self.Bind(wx.EVT_MENU, self.menu_exportdata_click, id=self.menu_exportdata_id)
        self.Bind(wx.EVT_BUTTON, self.addbutton_click, self.AddButton)
        self.Bind(wx.EVT_BUTTON, self.editbutton_click, self.EditButton)
        self.Bind(wx.EVT_BUTTON, self.removebutton_click, self.RemoveButton)
        self.Bind(wx.EVT_BUTTON, self.findwaist_click, self.FindWaistButton)
        self.Bind(wx.EVT_COMMAND_SCROLL, self.distanceslider_change, self.DistanceSlider)
        self.Bind(wx.EVT_TEXT_ENTER, self.edit_distance_change)
        #self.SchematicPanel.Bind(wx.EVT_PAINT, self.repaint_schematic) 
        self.Bind(wx.EVT_PAINT, self.paint_event) 
        self.SchematicPanel.Bind(wx.EVT_LEFT_UP, self.click_schematic) 
        self.SchematicPanel.Bind(wx.EVT_SIZE, self.resize_schematic) 
    
        # end wxGlade
        
        self.init_calculations()
        self.refresh_interface()
        self.refresh_grid_information()
        self.resize_schematic(None)

    def __set_properties(self):
        # begin wxGlade: VFFrame.__set_properties
        self.SetTitle("Virtual Femtolab")
        self.SetSize((900,675))
        self.VFData.CreateGrid(13, 3)
        self.VFData.SetRowLabelSize(0)
        self.VFData.SetColLabelSize(0)
        self.VFData.EnableEditing(0)
        self.VFData.SetColLabelValue(0, "Name")
        self.VFData.SetColLabelValue(1, "Value")
        self.VFData.SetColLabelValue(2, "Units")
        self.VFData.SetSize((255, 150)) #150 is wrong, but it works anyway. 255 is hardcoded - TODO:fix
        #self.SchematicPanel.SetSize((890, 160))
        #size = self.SchematicPanel.GetClientSize()
        #print size
        #self.buffer = wx.EmptyBitmap(size.width, size.height)
        #self.dc = wx.BufferedDC(None, self.buffer )
        #self.dc.SetBackground(wx.Brush('gray'))
        #self.dc.Clear()
        
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: VFFrame.__do_layout
        self.sizer_1 = wx.BoxSizer(wx.VERTICAL)
        self.sizer_2 = wx.BoxSizer(wx.VERTICAL)
        self.sizer_9 = wx.BoxSizer(wx.VERTICAL)
        self.sizer_6 = wx.BoxSizer(wx.HORIZONTAL)
        self.sizer_7 = wx.BoxSizer(wx.VERTICAL)
        self.sizer_8 = wx.BoxSizer(wx.HORIZONTAL)
        self.sizer_7.Add(self.plot, 1, wx.EXPAND, 0)
        self.sizer_8.Add(self.AddButton, 0, wx.ALL|wx.ALIGN_BOTTOM|wx.ALIGN_CENTER_HORIZONTAL, 5)
        self.sizer_8.Add(self.EditButton, 0, wx.ALL|wx.ALIGN_BOTTOM|wx.ALIGN_CENTER_HORIZONTAL, 5)
        self.sizer_8.Add(self.RemoveButton, 0, wx.ALL|wx.ALIGN_BOTTOM|wx.ALIGN_CENTER_HORIZONTAL, 5)
        self.sizer_8.Add(self.FindWaistButton, 0, wx.ALL|wx.ALIGN_BOTTOM|wx.ALIGN_CENTER_HORIZONTAL, 5)
        self.sizer_7.Add(self.sizer_8,0, wx.ALIGN_BOTTOM|wx.ALIGN_CENTER_HORIZONTAL, 0)
        self.sizer_6.Add(self.sizer_7, 3, wx.EXPAND, 0)
        self.sizer_6.Add(self.VFData,0,wx.EXPAND,0)
        self.sizer_2.Add(self.sizer_6, 1, wx.EXPAND, 0)
        self.sizer_9.Add(self.SchematicPanel, 4, wx.EXPAND, 0)
        self.sizer_10 = wx.BoxSizer(wx.HORIZONTAL)
        self.sizer_10.Add(self.DistanceSlider, 5, wx.ALL|wx.EXPAND, 5)
        self.sizer_10.Add(self.DistanceText, 1, wx.ALL|wx.EXPAND, 5)
        self.sizer_10.Add(self.DistanceLabel, 0, wx.ALL|wx.EXPAND, 5)
        self.sizer_9.Add(self.sizer_10, 1, wx.EXPAND, 0)
        self.sizer_2.Add(self.sizer_9, 0, wx.EXPAND, 0)
        self.sizer_1.Add(self.sizer_2, 1, wx.EXPAND, 0)
        self.SetSizer(self.sizer_1)
        self.Layout()
        # end wxGlade
        

    def init_grid_information(self):
        self.VFData.SetDefaultCellFont(wx.Font(12, wx.FONTFAMILY_SWISS, wx.NORMAL, wx.FONTWEIGHT_NORMAL))
        self.VFData.SetCellValue(0,0,'Num.Points')
        self.VFData.SetCellValue(1,0,'Delta T')
        self.VFData.SetCellValue(1,2,'fs')
        self.VFData.SetCellValue(2,0,'FWHM (iterative)')
        self.VFData.SetCellValue(2,2,'fs')
        self.VFData.SetCellValue(3,0,'FWHM (gaussian fit)')
        self.VFData.SetCellValue(3,2,'fs')        
        self.VFData.SetCellValue(4,0,'Spectral FWHM')
        self.VFData.SetCellValue(4,2,'nm')
        self.VFData.SetCellValue(5,0,'Beam Spot')
        self.VFData.SetCellValue(5,2,'mm')
        self.VFData.SetCellValue(6,0,'Beam Curvature')
        self.VFData.SetCellValue(6,2,'m')
        self.VFData.SetCellValue(7,0,'Peak Power')
        self.VFData.SetCellValue(7,2,'W')
        self.VFData.SetCellValue(8,0,'Peak Intensity')
        self.VFData.SetCellValue(8,2,'Wm^-2')
        self.VFData.SetCellValue(9,0,'Pulse Energy')
        self.VFData.SetCellValue(9,2,'J')
        self.VFData.SetCellValue(10,0,'Rep. Rate')
        self.VFData.SetCellValue(10,2,'MHz')
        self.VFData.SetCellValue(11,0,'CW Power')
        self.VFData.SetCellValue(11,2,'W')
        self.VFData.SetCellValue(12,0,'z')
        self.VFData.SetCellValue(12,2,'m')
                
        
        
        
        
        
        
################################ menu click events ################################        
        

    def menu_open_click(self, event): # wxGlade: VFFrame.<event_handler>
        dialog = wx.FileDialog(self,'Choose file to load state','./','state','Virtual Femtolab Setup(*.fs)|*.fs| All Files (*.*)|*.*',wx.FD_CHANGE_DIR)
        if(dialog.ShowModal() == wx.ID_OK):
            filename = dialog.GetFilename()
            infile = open(filename, 'rb')
            self.propagator = pickle.load(infile)
            infile.close()
            self.propagator.recreate_frogs()
            self.propagator.change_z(self.distance)
            self.refresh_everything()
        dialog.Destroy()
        

    def menu_save_click(self, event): # wxGlade: VFFrame.<event_handler>
        dialog = wx.FileDialog(self,'Choose file to save current state','./','state','Virtual Femtolab Setup|*.fs',wx.FD_SAVE|wx.FD_OVERWRITE_PROMPT|wx.FD_CHANGE_DIR)
        if(dialog.ShowModal() == wx.ID_OK):
            filename = dialog.GetFilename()
            if(filename[-3:] != '.fs'):
                filename = filename + '.fs'
            outfile = open(filename, 'wb')
            self.propagator.delete_frogs_for_output()
            pickle.dump(self.propagator, outfile)
            outfile.close()
            self.propagator.recreate_frogs()
        dialog.Destroy()

    def menu_exit_click(self, event): # wxGlade: VFFrame.<event_handler>
        self.Close()

    def menu_exportplots_click(self, event): # wxGlade: VFFrame.<event_handler>
        import export_dialog  #todo change this file's name
        dialog = export_dialog.ExportFrame(self)
        dialog.set_info(self.export)  #TODO: change the name to export function ,because it could be plots or data
        dialog.Show()
        
    def menu_exportdata_click(self, event): # wxGlade: VFFrame.<event_handler>
        dialog = wx.FileDialog(self,'Choose file prefix to save data','./','data','No extension. Data will be saved in various csv files.|*.',wx.FD_SAVE|wx.FD_OVERWRITE_PROMPT|wx.FD_CHANGE_DIR)
        if(dialog.ShowModal() == wx.ID_OK):
            filename = dialog.GetFilename()
            self.export_data(filename)
        dialog.Destroy()
        
    def menu_computational_window_click(self, event):
        import edit_computationalwindow
        dialog = edit_computationalwindow.EditComputationalWindow(self)
        dialog.set_info(self.NT,self.deltaT,self.propagator.get_pulseBeam().freqZero,self.change_computational_window,self.refresh_everything)
        dialog.Show()
        
    def menu_central_wavelength_click(self, event):
        import edit_centralwavelength
        dialog = edit_centralwavelength.EditCentralWavelength(self)
        dialog.set_info(3e8/self.propagator.get_pulseBeam().freqZero,self.change_central_wavelength,self.refresh_everything)
        dialog.Show()
        
        
################################ callbacks ################################        
        

    def change_computational_window(self, NT, deltaT):
        self.NT = NT
        self.deltaT = deltaT

        self.propagator.change_computational_window(NT, deltaT) 
        self.plot.reset()

    def change_central_wavelength(self, central_wavelength, wavelength_limit):
        self.lambdaZero = central_wavelength
        self.freqZero = 3e8/self.lambdaZero
        self.wavelength_limit = wavelength_limit

        self.propagator.change_central_wavelength(central_wavelength)
        self.plot.reset()
        
        
        
        
        
################################ button click events ################################        
        

    def addbutton_click(self, event): # wxGlade: VFFrame.<event_handler>
        event.Skip()
        # Open add dialog
        import add_dialog
        dialog = add_dialog.AddDialog(self)
        dialog.set_info(self.selected, self.propagator.add_element,self.refresh_everything) 
        dialog.Show()

    def editbutton_click(self, event): # wxGlade: VFFrame.<event_handler>
        if(self.selected == 0):
            import edit_initialpulse
            dialog = edit_initialpulse.EditInitialPulse(self)
            dialog.set_info(self.propagator.get_initialPulseBeam(),self.refresh_everything)
            dialog.Show()
            return
    
        name = str(self.propagator.get_elements()[self.selected-1].__class__)

        if(name == 'element_propagation.Element_Propagation'):
            import edit_materialpropagation
            dialog = edit_materialpropagation.EditMaterialPropagation(self)
            dialog.set_info(self.propagator.get_elements()[self.selected-1],self.propagator.get_materials(),self.refresh_everything)
            dialog.Show()
        elif(name == 'element_thinlens.Element_ThinLens'):
            import edit_thinlens
            dialog = edit_thinlens.EditThinLens(self)
            dialog.set_info(self.propagator.get_elements()[self.selected-1],self.refresh_everything)
            dialog.Show()
            
        event.Skip()

    def removebutton_click(self, event): # wxGlade: VFFrame.<event_handler>
        event.Skip()
        if(self.selected == 0 or self.selected > len(self.propagator.get_elements())):
            return
            
        element = self.propagator.get_elements()[self.selected-1]
        dialog = wx.MessageDialog(None, 'Are you sure you want to remove %s ?'%element.name, 'Confirmation', 
                    wx.YES_NO | wx.NO_DEFAULT | wx.ICON_QUESTION)
        if(dialog.ShowModal() == wx.ID_YES):
            self.propagator.remove_element(self.selected-1)
            self.selected = 0
            self.refresh_everything()
        
        
        
    def findwaist_click(self, event):
        event.Skip()
        z = self.propagator.get_next_waist()
        if(z < 0): #not found
            dialog = wx.MessageDialog(None, 'No more waists found.', 'Information', wx.OK|wx.ICON_INFORMATION)
            dialog.ShowModal()
            del dialog
        else:
            self.change_distance(z)
            self.DistanceSlider.SetValue(z*1000/self.propagator.get_max_z())
            
            
            
            
        
################################ other events ################################

    def distanceslider_change(self, event): # wxGlade: VFFrame.<event_handler>
        distance = self.DistanceSlider.GetValue()/1000.*self.propagator.get_max_z()
        if(abs(self.distance-distance) > 1e-15):
            self.change_distance(distance)

        event.Skip()
        
    def edit_distance_change(self,event):
        event.Skip()
        try:
            z = float(self.DistanceText.GetValue())
            self.change_distance(z)
        except:
            self.DistanceText.ChangeValue(str(self.distance))
        
        
        
################################ pulse calculation functions ################################        
                
        
    def init_calculations(self):
        #TODO: move this into a separate config file
        self.NT = config.NT
        self.deltaT = config.deltaT
        self.lambdaZero = config.lambdaZero
        self.wavelength_limit = config.lambdaZero*2
        self.propagator = propagator.Propagator(self.NT,self.deltaT,self.lambdaZero)
        self.propagator.example_pulseBeam()
        self.propagator.example_elements()
        
        self.distance = 0
        self.selected = 0
        
        

    def change_distance(self, distance):
        # Recalculate everything
        
        #keep within bounds
        if(distance < 0):
            distance = 0
        max_distance = self.propagator.get_max_z()
        if(distance > max_distance):
            distance = max_distance
            
        #recalculate
        self.distance = distance 
        self.propagator.change_z(distance)
    
        # Refresh interface/redraw
        self.DistanceText.ChangeValue(str(self.distance))
        self.refresh_interface()
        self.refresh_grid_information()
        self.repaint_schematic()
        
        
       
       
       
       
################################ interface redraw and refresh functions ################################       
       
        
    def refresh_everything(self):
        self.change_distance(self.distance)

    
    def refresh_interface(self):
        pulseBeam = self.propagator.get_pulseBeam()
        
        t = pulseBeam.get_t()
        
        envelope = pulseBeam.get_temporal_envelope()
        electric_field = pulseBeam.get_real_electric_field()
        temporal_phase = pulseBeam.get_temporal_phase()
        
        #the function is called phase_blank but we are using it here to remove the 
        # ~0 parts of the waveforms
        
        t_phase,temporal_phase = pulseBeam.phase_blank(t,envelope,temporal_phase,1e-2)
        if(not electric_field is None):
            t_field,electric_field = pulseBeam.phase_blank(t,envelope,electric_field,1e-3)        
        t_field,envelope = pulseBeam.phase_blank(t,envelope,envelope,1e-3)
        
        spectrum,spectral_phase,freq = pulseBeam.get_spectral_intensity_and_phase_vs_wavelength(self.wavelength_limit)
        #spectrum = pulseBeam.get_spectral_intensity()
        
        freq_phase = freq[:]
        #spectral_phase = pulseBeam.get_spectral_phase()
        freq_phase,spectral_phase = pulseBeam.phase_blank(freq_phase,spectrum,spectral_phase,1e-2)
        
        inter_autoco     = pulseBeam.get_interferometric_autoco()
        inten_autoco     = pulseBeam.get_intensiometric_autoco()

        t_autoco,inter_autoco = pulseBeam.phase_blank(t,inten_autoco-1,inter_autoco,1e-3)
        t_autoco,inten_autoco = pulseBeam.phase_blank(t,inten_autoco-1,inten_autoco,1e-3)
        
        frog, frog_limits = pulseBeam.get_SHGFROG()
        self.plot.redraw(t_field,envelope,electric_field,t_phase,temporal_phase,freq,spectrum,freq_phase,spectral_phase,t_autoco,inter_autoco,inten_autoco,frog,frog_limits)
        

        
    def refresh_grid_information(self):
        pulseBeam = self.propagator.get_pulseBeam()
        self.VFData.SetCellValue(0,1,'%d'%pulseBeam.NT)
        self.VFData.SetCellValue(1,1,'%3.1f'%(pulseBeam.deltaT*1e15))
        fwhm1,fwhm2 = pulseBeam.get_temporal_fwhm()
        self.VFData.SetCellValue(2,1,'%3.3f'%(fwhm2*1e15))
        self.VFData.SetCellValue(3,1,'%3.3f'%(fwhm1*1e15))
        self.VFData.SetCellValue(4,1,'%3.3f'%(pulseBeam.get_spectral_fwhm()*1e9))
        spot = pulseBeam.get_beam_spot()
        if(spot < 1e-3):
            self.VFData.SetCellValue(5,1,'%3.3e'%(spot*1e6))
            self.VFData.SetCellValue(5,2,'um')
        else:
            self.VFData.SetCellValue(5,1,'%3.3e'%(spot*1e3))
            self.VFData.SetCellValue(5,2,'mm')
        self.VFData.SetCellValue(6,1,'%3.3e'%(pulseBeam.get_beam_curvature()))
        self.VFData.SetCellValue(7,1,'%3.3e'%(pulseBeam.calc_peak_power()))
        self.VFData.SetCellValue(8,1,'%3.3e'%(pulseBeam.calc_peak_intensity()))
        self.VFData.SetCellValue(9,1,'%3.3e'%(pulseBeam.calc_energy()))
        rep_rate = pulseBeam.get_rep_rate()
        if(rep_rate < 1e6):
            self.VFData.SetCellValue(10,1,'%3.3e'%(rep_rate*1e-3))
            self.VFData.SetCellValue(10,2,'KHz')
        else:
            self.VFData.SetCellValue(10,1,'%3.3e'%(rep_rate*1e-6))
            self.VFData.SetCellValue(10,2,'MHz')
        self.VFData.SetCellValue(11,1,'%3.3e'%(pulseBeam.calc_CW_power()))
        self.VFData.SetCellValue(12,1,'%3.3e'%(self.distance))

        self.VFData.Fit()
    
    
    
    
    
################################ schematic related functions ################################        

    
    def click_schematic(self,event):
        event.Skip()

        width = config.schematic_element_width

        x = event.GetPosition()[0]
        
        elements = self.propagator.get_elements()
        
        #calculate how much to scroll
        total_width = (width+5)*(len(elements)+1)
        available_width = self.SchematicPanel.GetSizeTuple()[0]-10

        if(available_width > total_width):
            x -= 5
        else:
            x -= 5-self.distance/self.propagator.get_max_z()*(total_width-available_width)
            
        i = int(x/(width+5))
        
        if(i <= len(self.propagator.get_elements())):
            self.selected = i
            
        self.repaint_schematic()
        
    def paint_event(self,event):
        #event.Skip()
        dc = wx.BufferedPaintDC(self.SchematicPanel, self.buffer)
#        dc = wx.PaintDC(self.SchematicPanel)
        self.repaint_schematic()
    
        
    def repaint_schematic(self):
        dc = wx.BufferedPaintDC(self.SchematicPanel, self.buffer)
#        dc = wx.PaintDC(self.SchematicPanel)
        #dc.SetBackground(wx.Brush(self.GetBackgroundColour()))
        dc.SetBackground(wx.Brush('#efefef'))
        dc.BeginDrawing()
        dc.Clear()

        self.draw_schematic(dc)

        #event.Skip()
        dc.EndDrawing()
        
    def resize_schematic(self,event):
        size = self.SchematicPanel.GetClientSize()
        self.buffer = wx.EmptyBitmap(size.width, size.height)
        self.dc = wx.BufferedDC(None, self.buffer)
        
        
    def draw_schematic(self,dc):
        width = config.schematic_element_width
        height = config.schematic_element_height 
        
        elements = self.propagator.get_elements()
        
        #calculate how much to scroll
        total_width = (width+5)*(len(elements)+1)
        available_width = self.SchematicPanel.GetSizeTuple()[0]-10

        if(available_width > total_width):
            x = 5
        else:
            x = 5-self.distance/self.propagator.get_max_z()*(total_width-available_width)
        
        ipb = self.propagator.get_initialPulseBeam()
        tmp,t_fwhm = ipb.get_temporal_fwhm() 
        f_fwhm  = ipb.get_spectral_fwhm()
        text = '%.1f fs\n%.1f nm'%(t_fwhm*1e15,f_fwhm*1e9)
        
        
        if(self.selected == 0):
            selected = True
        else:
            selected = False
            
        draw_schematic.draw_initial_pulse(dc,x,width,height,text,selected) 
        x += width+5
        
        
        spots = self.propagator.get_spots()
        spots /= max(abs(array(spots)))
        
        z = 0
        
        for i in xrange(len(elements)):
            spot_in  = spots[2*i+0]
            spot_out = spots[2*i+1]
            if(self.selected == i+1):
                selected = True
            else:
                selected = False

            draw_schematic.draw_element(dc,x,width,height,elements[i],str(elements[i].__class__),selected,spot_in,spot_out)
            
            
            #should we draw the position line in this element?
            if(z <= self.distance and z+elements[i].length > self.distance):
                #calc position to draw the line
                line_x = x+(self.distance-z)/elements[i].length*width
                draw_schematic.draw_line(dc,line_x,height)
            
            z += elements[i].length
            x += width+5
            







################################ export callbacks ################################        


    def export(self,export_type, export_elements, numframes):
        if(export_elements == 1 and sys.platform=='darwin'):
            string = 'Please do not occlude the window during the process. Doing so will result in incorrect output.'
            dialog = wx.MessageDialog(self,string,'Important',wx.OK|wx.ICON_INFORMATION)
            dialog.ShowModal()
            del dialog
        
        if(export_type == 0): #export single frame
            dialog = wx.FileDialog(self,'Choose image file to save plots','./','plots.png','PNG file (*.png)|*.png',wx.FD_SAVE|wx.FD_OVERWRITE_PROMPT|wx.FD_CHANGE_DIR)
            if(dialog.ShowModal() == wx.ID_OK):
                filename = dialog.GetFilename()
                if(export_elements == 1): #everything
                    self.export_frame_all_elements(filename)
                else:
                    self.export_frame_field_and_spectrum(filename)
            dialog.Destroy()
        else:  #export animation
            dialog = wx.DirDialog(self,'Choose directory to save plot sequence','./',wx.DD_DIR_MUST_EXIST|wx.DD_CHANGE_DIR)
            if(dialog.ShowModal() == wx.ID_OK):
                path = dialog.GetPath()
                self.export_animation(path,numframes,export_elements)
                f=file(path+'/make_mpeg2.bat','w')
                f.write('mencoder -ovc lavc -lavcopts vcodec=mpeg2video:vbitrate=1500  -mf type=png:fps=5 -nosound -of mpeg -o output.mpg mf://*.png\n')
                f.write('./mencoder -ovc lavc -lavcopts vcodec=mpeg2video:vbitrate=1500  -mf type=png:fps=5 -nosound -of mpeg -o output.mpg mf://*.png')
                f.close()
                f=file(path+'/make_gif.bat','w')
                f.write('convert *.png  -delay 20 animation.gif')
                f.close()
                f=file(path+'/make_README.txt','w')
                f.write('You need imagemagick for make_gif.bat and mencoder for make_mpeg2.bat. In Linux or MacOSX, run with \'bash make_XXX.bat\'. Videos do not open in Quicktime' )
                f.close()
            dialog.Destroy()
            
    def export_animation(self,path,numframes,export_elements):
        import progress_dialog
        dialog = progress_dialog.ProgressFrame(self)
        dialog.Show()
        
        max_distance = self.propagator.get_max_z()
        
        dialog.set_frame(1,numframes)
                
        for i in xrange(numframes):
            filename = path+'/%0.6d.png'%(i+1)

            
            z = i*max_distance/(numframes-1)

            self.change_distance(z)
            
            dialog.set_frame(i+1,numframes)
            
            if(export_elements==0): #just electric field
                self.export_frame_field_and_spectrum(filename)
            else:
                self.export_frame_all_elements(filename)
            
        dialog.Destroy()
            
    def export_frame_field_and_spectrum(self,filename):
        #draw plots to buffer 2
        import StringIO, Image
        imgdata = StringIO.StringIO()
        self.plot.figure.savefig(imgdata, dpi=120,format='png')
        imgdata.seek(0)
        img = Image.open(imgdata)

        #import matplotlib nonGUI backend and use that
        from matplotlib.backends.backend_agg import FigureCanvasAgg as PngCanvas
        figure = mpl.figure.Figure(dpi=150, figsize=(16,6))
        canvas = PngCanvas(figure)
        figure.subplots_adjust(hspace = 0.33,wspace=0.33)
        plot1 = figure.add_subplot(121,title='Temporal Profile')
        plot2 = figure.add_subplot(122,title='Spectral Profile')
        
        
        #drawing code 
            
        pulseBeam = self.propagator.get_pulseBeam()
        t_envelope = pulseBeam.get_t()
        envelope = pulseBeam.get_temporal_envelope()
        electric_field = pulseBeam.get_real_electric_field()
        t_phase = t_envelope[:]
        temporal_phase = pulseBeam.get_temporal_phase()
        t_phase,temporal_phase = pulseBeam.phase_blank(t_phase,envelope,temporal_phase,1e-2)
        freq = pulseBeam.get_frequencies()
        spectrum = pulseBeam.get_spectral_intensity()
        freq_phase = freq[:]
        spectral_phase = pulseBeam.get_spectral_phase()
        freq_phase,spectral_phase = pulseBeam.phase_blank(freq_phase,spectrum,spectral_phase,1e-2)
        
        #efield
        plot1.plot(t_envelope, envelope, 'r')
        if(not electric_field is None):
            plot1.plot(t_envelope, electric_field, 'b')
        plot1_twinx = plot1.twinx()
        plot1_twinx.plot(t_phase, temporal_phase, 'k')
        
        plot1.set_xlabel('Time(s)',fontsize='small')
        plot1.set_ylabel('Electric Field(sqrt(Ws^-1))',fontsize='small')
        plot1_twinx.set_ylabel('Phase (rad))',fontsize='small')
        
        if(len(temporal_phase) > 0):
            max_phase = max(temporal_phase)
            min_phase = min(temporal_phase)
            delta = max_phase-min_phase
            if(delta < 0.1):
                plot1_twinx.set_ylim((-0.09,0.01))
        
        #spectral profile
        plot2.plot(freq, spectrum, 'g')
        plot2_twinx = plot2.twinx()
        plot2_twinx.plot(freq_phase, spectral_phase, 'k')
        
        plot2.set_xlabel('Envelope Frequency(rad s^-1)',fontsize='small')
        plot2.set_ylabel('Intensity (??sqrt(Ws^-1))',fontsize='small')
        plot2_twinx.set_ylabel('Phase (rad))',fontsize='small')
        
        figure.savefig(filename,format='png')
        del canvas
        del figure
        
        
    def export_frame_all_elements(self,filename):
        #draw schematic to buffer 1
        memorydc = wx.MemoryDC()
        size = self.SchematicPanel.GetSize()
        bitmap1 = wx.EmptyBitmap(size[0],size[1])
        memorydc.SelectObject(bitmap1)
        memorydc.SetBackground(wx.Brush('white'))
        memorydc.Clear()
        self.draw_schematic(memorydc)
        memorydc.SelectObject(wx.NullBitmap)
        memorydc.Destroy()
        #bitmap1.SaveFile(filename,wx.BITMAP_TYPE_PNG)
        import Image
        wximg = wx.ImageFromBitmap(bitmap1)
        img1 = Image.new('RGB', (wximg.GetWidth(), wximg.GetHeight()))
        img1.fromstring(wximg.GetData())
        
        #draw plots to buffer 2
        import StringIO
        imgdata = StringIO.StringIO()
        self.plot.figure.savefig(imgdata, dpi=75,format='png')
        imgdata.seek(0)
        img2 = Image.open(imgdata)
        
        #import VFData to buffer 3   #TODO: do this in a much reliable way!
        import sys
        if(sys.platform == 'darwin'): #workaround for macosx
            import os
            os.system('screencapture -x __tmp1.png')
            tmpimg = Image.open('__tmp1.png')
            os.system('rm __tmp1.png')
#            pos = self.GetRect()
            x,y = self.ClientToScreen((0,0))
            rect = self.VFData.GetRect()
#            img3 = tmpimg.crop((rect.x+pos.x,rect.y+pos.y+border.height,rect.x+pos.x+rect.width,rect.y+pos.y+rect.height+border.height))
            img3 = tmpimg.crop((rect.x+x,rect.y+y,rect.x+x+rect.width,rect.y+y+rect.height))
        else:
            rect = self.VFData.GetRect()
            dc = wx.ClientDC(self.VFData)
            bmp = wx.EmptyBitmap(rect.width, rect.height)
            memDC = wx.MemoryDC()
            memDC.SelectObject(bmp)
            memDC.Blit( 0, 0, rect.width,rect.height, dc,0,0)      
            memDC.SelectObject(wx.NullBitmap)
            import Image
            wximg = wx.ImageFromBitmap(bmp)
            img3 = Image.new('RGB', (wximg.GetWidth(), wximg.GetHeight()))
            img3.fromstring(wximg.GetData())
        
        width = img1.size[0]
        if(width < img2.size[0]+img3.size[0]):
            width = img2.size[0]+img3.size[0]
        height = img1.size[1]+img2.size[1]
        final_image = Image.new('RGB', (width, height),'white')
        final_image.paste(img2,(0,0))
        final_image.paste(img3,(img2.size[0],0))
        final_image.paste(img1,(0,img2.size[1]))

        final_image.save(filename)

        
    def export_data(self,filename):
        pulseBeam = self.propagator.get_pulseBeam()
        
        #export temporal data
        t_envelope = pulseBeam.get_t()
        envelope = pulseBeam.get_temporal_envelope()
        electric_field = pulseBeam.get_real_electric_field()
        temporal_phase = pulseBeam.get_temporal_phase()
        table = vstack((t_envelope,envelope))
        if(not electric_field is None):
            table = vstack((table,electric_field))
            string = 'time(s), envelope, electric field, phase'
        else:
            string = 'time(s),envelope,phase'
        table = vstack((table,temporal_phase))
        csv_utils.saveCSVtable(filename+'_temporal.csv',string,transpose(table))
        
        #export spectral data
        freq = pulseBeam.get_frequencies()
        wavelengths = pulseBeam.get_wavelengths()
        spectrum = pulseBeam.get_spectral_intensity()
        spectral_phase = pulseBeam.get_spectral_phase()
        #dont output negative or very high wavelengths
        i = 0
        while(wavelengths[i] <= 0 or wavelengths[i] > 1600e-9):
            i+=1
        table = vstack((freq[i:],wavelengths[i:]))
        table = vstack((table,spectrum[i:]))
        table = vstack((table,spectral_phase[i:]))
        string = 'envelope frequency, wavelength, spectrum, spectral phase'
        csv_utils.saveCSVtable(filename+'_spectral.csv',string,transpose(table))
        
        #export autocorrelation
        t = pulseBeam.get_t()
        inter_autoco     = pulseBeam.get_interferometric_autoco()
        inten_autoco     = pulseBeam.get_intensiometric_autoco()
        table = vstack((t,inten_autoco))
        table = vstack((table,inter_autoco))
        string = 't, inter_autoco, inten_autoco'
        csv_utils.saveCSVtable(filename+'_autoco.csv',string,transpose(table))
        
        #to export frog, uncomment these lines
        # removed it because it produced big files and probably few people will use raw frog data
        #frog, frog_limits = pulseBeam.get_SHGFROG()
        #csv_utils.saveCSVtable(filename+'_frog.csv','',frog)
        
        
        
        
        
        
        
# end of class VFFrame

def main():
    app = wx.PySimpleApp(0)
    wx.InitAllImageHandlers()
    MainFrame = VFFrame(None, -1, "")
    app.SetTopWindow(MainFrame)
    MainFrame.Show()
    app.MainLoop()
